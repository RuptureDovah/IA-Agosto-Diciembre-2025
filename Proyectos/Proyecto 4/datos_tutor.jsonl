{"instruction":"Explica Colas / Queues (resumen)","response":"Una Cola es una estructura de datos lineal que sigue el principio FIFO (First In, First Out): el primero en entrar es el primero en salir. Imagina una fila en el supermercado.\n\nOperaciones clave:\n- Enqueue: Agregar al final.\n- Dequeue: Sacar del frente.\nEs fundamental para gestionar procesos en orden de llegada."}
{"instruction":"Explica Colas (práctico)","response":"Caso de uso real: Una impresora compartida.\n\nCuando varios usuarios envían documentos, la impresora no puede imprimirlos todos a la vez. Los pone en una 'Cola'. El primer documento que llegó se imprime primero. Si usaras una Pila (Stack), el último en llegar se imprimiría antes, lo cual sería injusto."}
{"instruction":"Explica Hash Tables (resumen)","response":"Una Hash Table (tabla hash) es una estructura que almacena datos en pares clave-valor. Utiliza una función hash para calcular un índice en un arreglo donde se guardará el valor.\n\nVentaja principal: Búsqueda, inserción y eliminación son extremadamente rápidas, idealmente O(1) en tiempo promedio."}
{"instruction":"Explica Hash Tables (entrevista)","response":"Las Hash Tables ofrecen acceso instantáneo a datos mediante una clave (como un diccionario real). En una entrevista, menciona las 'colisiones' (cuando dos claves generan el mismo hash) y cómo se resuelven (encadenamiento o direccionamiento abierto). Son la base de los diccionarios en Python o Maps en Java."}
{"instruction":"Explica Recursividad (concepto)","response":"La recursividad es una técnica donde una función se llama a sí misma para resolver un problema. Debe tener dos partes:\n1) Caso Base: La condición que detiene la recursión.\n2) Caso Recursivo: La llamada a sí misma con un problema más pequeño.\n\nÚtil para problemas dividibles como el factorial o recorrer árboles."}
{"instruction":"Explica Recursividad con un ejemplo sencillo","response":"Ejemplo clásico: Factorial de n.\n\ndef factorial(n):\n    if n == 1: return 1  # Caso base\n    return n * factorial(n-1)  # Llamada recursiva\n\nSi olvidas el caso base, tendrás un error de 'Stack Overflow' (desbordamiento de pila)."}
{"instruction":"Explica Grafos (resumen)","response":"Un Grafo es un conjunto de nodos (vértices) conectados por enlaces (aristas). A diferencia de los árboles, no tienen jerarquía estricta y pueden contener ciclos.\n\nTipos:\n- Dirigidos (flechas en un sentido, como links de web).\n- No dirigidos (conexiones bidireccionales, como amigos en Facebook).\n- Ponderados (las aristas tienen peso/costo)."}
{"instruction":"Explica Grafos (usos prácticos)","response":"Los grafos se usan para modelar relaciones complejas:\n1. Mapas GPS: Nodos son intersecciones, aristas son calles (con peso = distancia/tráfico).\n2. Redes Sociales: Quién sigue a quién.\n3. Internet: Cómo se conectan los servidores entre sí."}
{"instruction":"Explica Arreglos / Arrays (resumen)","response":"Un Arreglo es la estructura más básica: una colección de elementos (usualmente del mismo tipo) almacenados en memoria contigua. \n\nVentaja: Acceso instantáneo por índice O(1).\nDesventaja: Tamaño fijo en muchos lenguajes; insertar o borrar en medio es lento O(n) porque requiere desplazar elementos."}
{"instruction":"Explica Búsqueda Binaria (resumen)","response":"Algoritmo eficiente para encontrar un elemento en una lista ORDENADA. Divide el espacio de búsqueda a la mitad en cada paso.\n\nComplejidad: O(log n).\nComparación: Buscar en 1 millón de datos toma ~20 pasos, mientras que una búsqueda lineal tomaría 1 millón."}
{"instruction":"Explica Búsqueda Binaria (ejemplo visual)","response":"Imagina buscar 'Gato' en un diccionario. No pasas hoja por hoja (lineal). Abres a la mitad: sale 'Mesa'. Como 'Gato' está antes, descartas la mitad derecha. Repites el proceso con la mitad izquierda. Eso es búsqueda binaria."}
{"instruction":"Explica Algoritmos Greedy (Voraces)","response":"Un algoritmo Greedy toma la decisión que parece óptima en ese momento preciso (óptimo local), con la esperanza de llegar a la solución general óptima.\n\nEjemplo: Dar cambio con el menor número de monedas. Siempre tomas la moneda de mayor valor posible primero. Nota: No funcionan para todos los problemas."}
{"instruction":"Explica Búsqueda Lineal (resumen)","response":"Es el método más simple: recorrer una lista elemento por elemento desde el inicio hasta encontrar lo que buscas o llegar al final.\n\nCuándo usarla: Cuando la lista está desordenada o es muy pequeña. Su complejidad es O(n)."}
{"instruction":"Explica Pilas / Stacks (resumen)","response":"Una Pila es una estructura LIFO (Last In, First Out): el último en entrar es el primero en salir. Como una pila de platos sucios.\n\nOperaciones:\n- Push: Poner arriba.\n- Pop: Quitar de arriba.\nUso común: La función 'Deshacer' (Ctrl+Z) de los editores de texto."}
{"instruction":"Explica Listas Enlazadas (resumen)","response":"Una Lista Enlazada consiste en nodos donde cada uno guarda un valor y una referencia (puntero) al siguiente nodo. No están contiguos en memoria.\n\nVentaja vs Arreglos: Inserción y borrado eficiente (solo cambias punteros).\nDesventaja: Acceso lento O(n), debes recorrerla desde el inicio para llegar al elemento 50."}
{"instruction":"Explica Complejidad Espacial","response":"La Complejidad Espacial mide cuánta memoria extra necesita un algoritmo para ejecutarse en relación al tamaño de la entrada (n).\n\nEjemplo:\n- O(1): Usar una sola variable auxiliar (muy eficiente).\n- O(n): Crear una copia completa de una lista (consume más memoria)."}
{"instruction":"Explica Complejidad Temporal","response":"La Complejidad Temporal estima cómo aumenta el tiempo de ejecución de un algoritmo al crecer la entrada.\n\nJerarquía básica (de mejor a peor):\n1. O(1) - Constante\n2. O(log n) - Logarítmica\n3. O(n) - Lineal\n4. O(n^2) - Cuadrática (bucles anidados)."}
{"instruction":"Explica Divide y Vencerás","response":"Estrategia que resuelve un problema complejo dividiéndolo en subproblemas más simples del mismo tipo, resolviéndolos (a menudo recursivamente) y combinando sus resultados.\n\nEjemplo estrella: Merge Sort. Divide la lista en dos mitades, las ordena recursivamente y luego las mezcla ('merge')."}
{"instruction":"Explica Algoritmos de Ordenamiento","response":"Son procedimientos para organizar elementos en una secuencia (numérica o alfabética). \n\n- Simples pero lentos: Bubble Sort, Insertion Sort O(n^2).\n- Complejos pero rápidos: Quick Sort, Merge Sort O(n log n).\nElegir el correcto optimiza el rendimiento general del software."}
{"instruction":"Explica Árboles Binarios","response":"Estructura de datos jerárquica donde cada nodo tiene como máximo dos hijos: hijo izquierdo e hijo derecho.\n\nUso clave: Árboles de Búsqueda Binaria (BST), donde los menores van a la izquierda y los mayores a la derecha, optimizando la búsqueda de datos."}
{"instruction":"Explica Colas (resumen)","response":"Una Cola (Queue) es una estructura lineal que sigue el orden FIFO (First In, First Out). El primero en llegar es el primero en ser atendido, igual que en una fila del banco.\n\nOperaciones principales:\n- Enqueue (encolar): Añadir al final.\n- Dequeue (desencolar): Sacar del frente.\nEs esencial para manejar tareas asíncronas."}
{"instruction":"Explica Colas (práctico)","response":"Caso real: Gestión de una impresora.\n\nCuando envías 5 archivos a imprimir, la impresora no puede hacerlos todos a la vez. Los guarda en una Cola en memoria. Imprime el primero que llegó, luego el segundo, etc. Si usara una Pila, imprimiría el último que enviaste primero, lo cual sería confuso."}
{"instruction":"Explica Hash Tables (resumen)","response":"Una Hash Table (tabla hash) asocia claves con valores (como un diccionario). Usa una función hash para calcular dónde guardar el dato en memoria.\n\nVentaja: Búsqueda, inserción y borrado son muy rápidos, idealmente O(1) en tiempo promedio."}
{"instruction":"Explica Hash Tables (entrevista)","response":"Las Hash Tables son la base de los diccionarios en Python o HashMaps en Java. En una entrevista, recuerda mencionar las 'colisiones' (cuando dos claves generan el mismo hash) y cómo se resuelven (encadenamiento o direccionamiento abierto)."}
{"instruction":"Explica Recursividad (concepto)","response":"La recursividad ocurre cuando una función se llama a sí misma. Para que no sea infinita, necesita:\n1. Caso Base: La condición de parada (ej. n == 0).\n2. Caso Recursivo: La llamada a sí misma con un problema más pequeño.\n\nÚtil para navegar estructuras jerárquicas como árboles o carpetas."}
{"instruction":"Explica Recursividad (ejemplo)","response":"Ejemplo clásico: Factorial.\n\ndef factorial(n):\n    if n <= 1: return 1  # Caso base\n    return n * factorial(n - 1)  # Llamada recursiva\n\nSi olvidas el caso base, tendrás un error de 'Stack Overflow' (desbordamiento de pila) porque la memoria se llena."}
{"instruction":"Explica Grafos (resumen)","response":"Un Grafo es un conjunto de nodos (vértices) conectados por enlaces (aristas). A diferencia de los árboles, no tienen una raíz única y pueden tener ciclos (caminos circulares).\n\nTipos:\n- Dirigidos: Las conexiones tienen sentido (A -> B).\n- No dirigidos: Conexiones bidireccionales (A <-> B).\n- Ponderados: Las conexiones tienen un costo o peso."}
{"instruction":"Explica Grafos (usos reales)","response":"Los grafos modelan relaciones complejas:\n- Redes sociales: Persona = Nodo, Amistad = Arista.\n- GPS/Mapas: Intersección = Nodo, Calle = Arista (peso = distancia).\n- Internet: Página web = Nodo, Hipervínculo = Arista."}
{"instruction":"Explica Arreglos (Arrays)","response":"Un Arreglo es una colección de elementos almacenados en memoria contigua. Tienen tamaño fijo (en lenguajes de bajo nivel) y acceso indexado muy rápido O(1).\n\nDesventaja: Insertar o borrar elementos en medio es lento O(n) porque requiere desplazar el resto de los elementos."}
{"instruction":"Explica Búsqueda Binaria (resumen)","response":"Algoritmo eficiente para encontrar un elemento en una lista ORDENADA. Divide el rango de búsqueda a la mitad repetidamente.\n\nComplejidad: O(log n).\nEs mucho más rápida que la lineal para grandes volúmenes de datos (ej. buscar en una guía telefónica)."}
{"instruction":"Explica Algoritmos Greedy (Voraces)","response":"Un algoritmo Greedy toma la mejor decisión posible en el momento actual (óptimo local) esperando llegar a la solución general óptima. No se arrepiente ni vuelve atrás.\n\nEjemplo: El problema del cambio. Para dar 60 centavos con las menos monedas posibles, primero tomas la de 50, luego la de 10."}
{"instruction":"Explica Búsqueda Lineal","response":"Es el método más simple: revisar cada elemento de la lista uno por uno hasta encontrar el objetivo o llegar al final.\n\nUso: Cuando la lista es pequeña o NO está ordenada. Su complejidad es O(n) (proporcional al tamaño de la lista)."}
{"instruction":"Explica Pilas (Stacks)","response":"Una Pila es una estructura LIFO (Last In, First Out). El último elemento en entrar es el primero en salir. Imagina una pila de platos sucios.\n\nOperaciones:\n- Push: Apilar (poner arriba).\n- Pop: Desapilar (sacar de arriba).\nUso común: La función 'Deshacer' (Ctrl+Z) y la pila de llamadas de funciones en programación."}
{"instruction":"Explica Listas Enlazadas (resumen)","response":"Una Lista Enlazada consiste en nodos donde cada uno guarda un valor y un puntero (referencia) al siguiente nodo. No requieren memoria contigua.\n\nVentaja: Insertar/Borrar es rápido si tienes la referencia.\nDesventaja: Acceso lento O(n), debes recorrerla nodo por nodo para llegar al final."}
{"instruction":"Explica Complejidad Espacial","response":"La Complejidad Espacial analiza cuánta memoria adicional necesita un algoritmo para funcionar en relación al tamaño de la entrada (n).\n\n- O(1): Uso de memoria constante (ej. un par de variables).\n- O(n): Uso lineal (ej. crear una copia de una lista).\nOptimizar espacio es crucial en sistemas embebidos o móviles."}
{"instruction":"Explica Complejidad Temporal","response":"La Complejidad Temporal estima cómo crece el tiempo de ejecución de un algoritmo al aumentar los datos de entrada.\n\nOrden de eficiencia (de mejor a peor):\n1. O(1) - Constante\n2. O(log n) - Logarítmica\n3. O(n) - Lineal\n4. O(n^2) - Cuadrática (bucles anidados)."}
{"instruction":"Explica Divide y Vencerás","response":"Estrategia de diseño de algoritmos que:\n1. Divide el problema en subproblemas más pequeños.\n2. Vence (resuelve) los subproblemas (usualmente con recursión).\n3. Combina las soluciones.\n\nEjemplos famosos: Merge Sort, Quick Sort y Búsqueda Binaria."}
{"instruction":"Explica Algoritmos de Ordenamiento","response":"Son métodos para organizar datos en una secuencia (numérica o alfabética).\n\n- Simples: Bubble Sort (burbuja), Insertion Sort.\n- Eficientes: Merge Sort, Quick Sort (O(n log n)).\nElegir el adecuado depende del volumen de datos y la memoria disponible."}
{"instruction":"Explica Árboles Binarios","response":"Un Árbol Binario es una estructura jerárquica donde cada nodo tiene como máximo dos hijos (izquierdo y derecho).\n\nImportante: En los Árboles de Búsqueda Binaria (BST), el hijo izquierdo es menor y el derecho es mayor que el padre, lo que permite búsquedas rápidas similares a la búsqueda binaria."}
{"instruction":"Explica Algoritmos de Ordenamiento (comparativa)","response":"No hay un algoritmo 'mejor' para todo. \n- QuickSort: Generalmente el más rápido (O(n log n)), pero inestable y O(n^2) en el peor caso.\n- MergeSort: Estable y garantizado O(n log n), pero usa memoria extra O(n).\n- BubbleSort: Lento O(n^2), solo útil para enseñar o listas casi ordenadas."}
{"instruction":"Explica Grafos: Matriz vs Lista de Adyacencia","response":"Dos formas de representar grafos:\n1. Matriz de Adyacencia: Matriz NxN. Rápida para consultar si existe conexión O(1), pero gasta mucha memoria O(V^2). Úsala en grafos densos.\n2. Lista de Adyacencia: Arreglo de listas. Ahorra espacio O(V+E). Úsala en grafos dispersos (pocas conexiones), es el estándar en la industria."}
{"instruction":"Explica Complejidad Espacial vs Temporal (Trade-off)","response":"A menudo existe un intercambio (trade-off) entre tiempo y espacio. \nEjemplo: Una Hash Table acelera la búsqueda a O(1) (tiempo) a cambio de usar más memoria para almacenar claves y manejar colisiones (espacio). Mejorar uno suele costar en el otro."}
{"instruction":"Explica la localidad de caché en Arreglos","response":"Los Arreglos son amigables con la caché del CPU porque sus datos están contiguos en memoria física. Esto permite al procesador pre-cargar datos eficientemente. Las Listas Enlazadas, al tener nodos dispersos en la memoria, provocan más 'cache misses', siendo más lentas en la práctica aunque tengan la misma complejidad teórica."}
{"instruction":"Explica recorridos en Árboles Binarios (DFS vs BFS)","response":"- DFS (Depth First Search): Profundidad primero (Pre-order, In-order, Post-order). Usa una Pila (o recursión). Útil para puzzles o laberintos.\n- BFS (Breadth First Search): Anchura primero (Nivel por nivel). Usa una Cola. Útil para encontrar el camino más corto en grafos no ponderados."}
{"instruction":"¿Por qué usar Búsqueda Lineal si existe la Binaria?","response":"La Búsqueda Binaria es O(log n) pero requiere que los datos estén ORDENADOS. Ordenar toma O(n log n).\nSi vas a buscar una sola vez, o si la lista es pequeña o cambia muy frecuentemente (haciendo costoso mantener el orden), la Búsqueda Lineal O(n) es más eficiente."}
{"instruction":"Explica Colas de Prioridad (Priority Queues)","response":"Es una variación de la cola donde cada elemento tiene una 'prioridad'. Los elementos con mayor prioridad salen primero, sin importar cuándo llegaron.\nImplementación eficiente: Heaps (Montículos) binarios. \nUso real: El planificador de procesos del sistema operativo (CPU scheduling)."}
{"instruction":"Explica Notación Big O (intuición)","response":"Big O describe el peor escenario de crecimiento.\n- O(1): Tiempo constante (acceder a array).\n- O(log n): Cortar a la mitad (búsqueda binaria).\n- O(n): Recorrer todo (búsqueda lineal).\n- O(n log n): Ordenar eficientemente (MergeSort).\n- O(n^2): Bucles anidados (BubbleSort)."}
{"instruction":"Explica Búsqueda Binaria y memoria","response":"La Búsqueda Binaria requiere acceso aleatorio O(1) a los índices. Funciona perfecto en Arreglos. No se recomienda en Listas Enlazadas porque llegar al elemento medio toma O(n/2), eliminando la ventaja de eficiencia del algoritmo."}
{"instruction":"Explica Divide y Vencerás (pasos)","response":"Paradigma de tres pasos:\n1. Dividir: Partir el problema en subproblemas disjuntos.\n2. Vencer: Resolver los subproblemas (recursivamente).\n3. Combinar: Juntar las soluciones para resolver el problema original.\nEjemplo: Merge Sort divide la lista, ordena las partes y luego las mezcla."}
{"instruction":"Explica Hash Tables: Colisiones","response":"Una colisión ocurre cuando dos claves distintas generan el mismo índice hash. Soluciones:\n1. Encadenamiento (Chaining): Cada índice tiene una lista enlazada con los valores.\n2. Direccionamiento Abierto (Open Addressing): Si el lugar está ocupado, busca el siguiente espacio libre (Probing)."}
{"instruction":"Explica Pilas (Stacks) en validación de sintaxis","response":"Problema clásico: Validar paréntesis balanceados '(([]))'.\nAlgoritmo: \n- Si ves apertura '(', apila.\n- Si ves cierre ')', desapila y verifica que coincida.\n- Al final, si la pila está vacía, es válido. Si sobra algo o intentas desapilar de vacío, es inválido."}
{"instruction":"Explica Listas Enlazadas Dobles","response":"En una lista doble, cada nodo tiene referencia al siguiente Y al anterior. Permite recorrerla en ambas direcciones.\nVentaja: Borrar un nodo es O(1) si ya tienes el puntero al nodo (porque conoces su anterior), en una lista simple sería O(n)."}
{"instruction":"Explica Algoritmos Greedy: Problema de la Mochila","response":"En el problema de la mochila fraccionaria (puedes llevar polvo de oro), Greedy funciona: tomas lo que tenga mayor valor por kilo. \nEn la mochila 0/1 (barras de oro enteras), Greedy falla porque no ve combinaciones futuras; ahí necesitas Programación Dinámica."}
{"instruction":"Explica Recursividad de Cola (Tail Recursion)","response":"Es un tipo especial de recursión donde la llamada recursiva es lo ÚLTIMO que hace la función. Algunos compiladores pueden optimizar esto transformándolo en un bucle internamente, evitando el desbordamiento de pila (Stack Overflow). Python no soporta esta optimización nativamente."}